{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "QHnVupBBn9eR"
      },
      "source": [
        "\n",
        "# Assignment 3\n",
        "\n",
        "This is a template notebook for Assignment 3.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vM54r6jlKTII"
      },
      "source": [
        "## Install dependencies and initialization"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "9_FzH13EjseR"
      },
      "outputs": [],
      "source": [
        "# The next 8 lines added to be compatible with version changes (2022/10/13).\n",
        "# change cuda to 11.1\n",
        "import os\n",
        "p = os.getenv('PATH')\n",
        "ld = os.getenv('LD_LIBRARY_PATH')\n",
        "os.environ['PATH'] = f\"/usr/local/cuda-11.1/bin:{p}\"\n",
        "os.environ['LD_LIBRARY_PATH'] = f\"/usr/local/cuda-11.1/lib64:{ld}\"\n",
        "# change pytorch to 1.9.0 compiled with cuda 11.1\n",
        "!pip install torch==1.9.0+cu111 torchvision==0.10.0+cu111 -f https://download.pytorch.org/whl/torch_stable.html\n",
        "\n",
        "\n",
        "# install dependencies: \n",
        "!pip install pyyaml==5.1 pycocotools>=2.0.1\n",
        "# !pip install detectron2 -f https://dl.fbaipublicfiles.com/detectron2/wheels/cu101/torch1.6/index.html\n",
        "!pip install detectron2 -f https://dl.fbaipublicfiles.com/detectron2/wheels/cu111/torch1.9/index.html"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "dqAUb5Y12qXt"
      },
      "outputs": [],
      "source": [
        "!pwd # shows current directory\n",
        "!ls  # shows all files in this directory\n",
        "!nvidia-smi # shows the specs and the current status of the allocated GPU"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b-i4hmGYk1dL",
        "outputId": "4e3683e9-2531-4ede-f30e-2fe4394a9c4c"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "<Logger detectron2 (DEBUG)>"
            ]
          },
          "metadata": {},
          "execution_count": 3
        }
      ],
      "source": [
        "# import some common libraries\n",
        "from google.colab.patches import cv2_imshow\n",
        "from sklearn.metrics import jaccard_score\n",
        "from PIL import Image, ImageDraw\n",
        "from tqdm.notebook import tqdm\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import datetime\n",
        "import random\n",
        "import json\n",
        "import cv2\n",
        "import csv\n",
        "import os\n",
        "\n",
        "# import some common pytorch utilities\n",
        "from torch.utils.data import Dataset, DataLoader\n",
        "import torchvision.transforms as transforms\n",
        "from torch.autograd import Variable\n",
        "import torch.nn.functional as F\n",
        "import torch.nn as nn\n",
        "import torch\n",
        "import random_split\n",
        "\n",
        "# import some common detectron2 utilities\n",
        "import detectron2\n",
        "from detectron2 import model_zoo\n",
        "from detectron2.config import get_cfg\n",
        "from detectron2.structures import BoxMode\n",
        "from detectron2.engine import DefaultTrainer\n",
        "from detectron2.engine import DefaultPredictor\n",
        "from detectron2.utils.logger import setup_logger\n",
        "from detectron2.utils.visualizer import ColorMode\n",
        "from detectron2.utils.visualizer import Visualizer\n",
        "from detectron2.data import build_detection_test_loader\n",
        "from detectron2.data import MetadataCatalog, DatasetCatalog\n",
        "from detectron2.evaluation import COCOEvaluator, inference_on_dataset\n",
        "setup_logger()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "tUA_j6AF1L5Y"
      },
      "outputs": [],
      "source": [
        "# Make sure that GPU is available for your notebook. \n",
        "# Otherwise, you need to update the settungs in Runtime -> Change runtime type -> Hardware accelerator\n",
        "torch.cuda.is_available()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ZyAvNCJMmvFF",
        "outputId": "38109e6e-3bab-4601-e1a1-8f75d684c55e"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Mounted at /content/drive\n"
          ]
        }
      ],
      "source": [
        "# You need to mount your google drive in order to load the data:\n",
        "from google.colab import drive\n",
        "drive.mount('/content/drive')\n",
        "# Put all the corresponding data files in a data folder and put the data folder in a same directory with this notebook.\n",
        "# Also create an output directory for your files such as the trained models and the output images."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "A_Di_fgL4HSv"
      },
      "outputs": [],
      "source": [
        "# Define the location of current directory, which should contain data/train, data/test, and data/train.json.\n",
        "# TODO: approx 1 line\n",
        "BASE_DIR = '/content/drive/My Drive/CMPT_CV_lab3'\n",
        "OUTPUT_DIR = '{}/output'.format(BASE_DIR)\n",
        "os.makedirs(OUTPUT_DIR, exist_ok=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "Vk4gID50K03a"
      },
      "source": [
        "## Part 1: Object Detection"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "xRV-KFJzlur4"
      },
      "source": [
        "### Data Loader"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "dq9GY37ml1kr"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# This function should return a list of data samples in which each sample is a dictionary. \n",
        "# Make sure to select the correct bbox_mode for the data\n",
        "# For the test data, you only have access to the images, therefore, the annotations should be empty.\n",
        "# Other values could be obtained from the image files.\n",
        "# TODO: approx 35 lines\n",
        "'''\n",
        "def get_detection_data(set_name):\n",
        "  data_dirs = '{}/data'.format(BASE_DIR)\n",
        "  dataset = []\n",
        "  set_name.lower()\n",
        "  if set_name == 'train':\n",
        "    json_file = os.path.join(data_dirs, \"train.json\")\n",
        "    with open(json_file) as f:\n",
        "        imgs_anns = json.load(f)   \n",
        "    \n",
        "    id_check = [] # Storing the image ids\n",
        "    \n",
        "    for idx, v in enumerate(imgs_anns):\n",
        "        image_id = v[\"image_id\"]\n",
        "        object_ = { \"bbox\": v[\"bbox\"],\n",
        "                \"bbox_mode\": BoxMode.XYWH_ABS,\n",
        "                \"category_id\": 0,\n",
        "                \"category_name\": \"plane\",\n",
        "                \"segmentation\": v[\"segmentation\"],\n",
        "                \"iscrowd\": v[\"iscrowd\"],\n",
        "                \"area\": v[\"area\"] }\n",
        "        \n",
        "        if image_id in id_check: # Checking if the instance is from a new image or not\n",
        "          dataset[id_check.index(image_id)][\"annotations\"].append(object_)       \n",
        "        else:                      \n",
        "          filename = os.path.join(data_dirs, \"train\", v[\"file_name\"])\n",
        "          height, width = cv2.imread(filename).shape[:2] \n",
        "          record = { \"file_name\": filename,\n",
        "                     \"image_id\": image_id,\n",
        "                     \"height\": height,\n",
        "                     \"width\": width,\n",
        "                     \"annotations\": [obj] } \n",
        "          dataset.append(record)\n",
        "          id_check.append(image_id)\n",
        "    dataset_train, dataset_validation = random_split(dataset, [148,50]])  \n",
        "  elif set_name == \"test\":\n",
        "    directs = os.listdir(os.path.join(data_dirs, set_name))\n",
        "    for idx, file_n in enumerate(directs):        \n",
        "        filename = os.path.join(data_dirs, \"test\", file_n)\n",
        "        height, width = cv2.imread(filename).shape[:2] \n",
        "        record = { \"file_name\": filename,\n",
        "                    \"height\": height,\n",
        "                    \"width\": width,\n",
        "                    \"image_id\": idx,\n",
        "                    \"annotations\": [] }      \n",
        "        dataset.append(record)\n",
        "  output_dataset = []\n",
        "  if set_name == \"train\":\n",
        "    output_dataset = dataset_train\n",
        "  elif set_name == \"val\":\n",
        "    output_dataset = dataset_validation\n",
        "  elif set_name == \"test\":\n",
        "    output_dataset = dataset\n",
        "\n",
        "  return output_dataset"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "xCH-2mWxDVVu"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Remember to add your dataset to DatasetCatalog and MetadataCatalog\n",
        "# Consdier \"data_detection_train\" and \"data_detection_test\" for registration\n",
        "# You can also add an optional \"data_detection_val\" for your validation by spliting the training data\n",
        "# TODO: approx 5 lines\n",
        "'''\n",
        "from sklearn.model_selection import train_test_split\n",
        "for d in [\"train\", \"val\", \"test\"]:\n",
        "    DatasetCatalog.register(\"data_detection_\" + d, lambda d=d: get_detection_data(d))\n",
        "    MetadataCatalog.get(\"data_detection_\" + d).set(thing_classes=[\"plane\"])\n",
        "data_detection_train = DatasetCatalog.get(\"data_detection_train\")\n",
        "data_detection_val = DatasetCatalog.get(\"data_detection_val\")\n",
        "data_detection_test = DatasetCatalog.get(\"data_detection_test\")\n",
        "metadata_detection_test = MetadataCatalog.get(\"data_detection_test\")  "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "qNSdXCL_DVAz"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Visualize some samples using Visualizer to make sure that the function works correctly\n",
        "# TODO: approx 5 lines\n",
        "'''\n",
        "for id in random.sample(data_detection_train, 3):\n",
        "    img = cv2.imread(id[\"file_name\"])\n",
        "    visualizer = Visualizer(img[:, :, ::-1], metadata=metadata_detection_test, scale=0.5)\n",
        "    out = visualizer.draw_dataset_dict(id)\n",
        "    gt_mask = cv2.resize(out.get_image()[:, :, ::-1], (512,512), interpolation= cv2.INTER_NEAREST)\n",
        "    cv2_imshow(out)    \n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "uM1thbN-ntjI"
      },
      "source": [
        "### Set Configs"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "HUjkwRsOn1O0"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Set the configs for the detection part in here.\n",
        "# TODO: approx 15 lines\n",
        "'''\n",
        "cfg = get_cfg()\n",
        "cfg.OUTPUT_DIR = \"{}/output/\".format(BASE_DIR)\n",
        "#fg.merge_from_file(model_zoo.get_config_file(\"COCO-Detection/faster_rcnn_R_101_DC5_3x.yaml\"))\n",
        "#fg.merge_from_file(model_zoo.get_config_file(\"COCO-Detection/faster_rcnn_R_101_FPN_3x.yaml\"))\n",
        "#fg.merge_from_file(model_zoo.get_config_file(\"COCO-Detection/faster_rcnn_R_101_C4_3x.yaml\"))\n",
        "cfg.merge_from_file(model_zoo.get_config_file(\"COCO-Detection/faster_rcnn_X_101_32x8d_FPN_3x.yaml\"))\n",
        "cfg.DATASETS.TRAIN = (\"data_detection_train\",)\n",
        "cfg.DATASETS.TEST = ()\n",
        "cfg.DATALOADER.NUM_WORKERS = 8\n",
        "#cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(\"COCO-Detection/faster_rcnn_R_101_DC5_3x.yaml\")\n",
        "#cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(\"COCO-Detection/faster_rcnn_R_101_FPN_3x.yaml\")\n",
        "#cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(\"COCO-Detection/faster_rcnn_R_101_C4_3x.yaml\")\n",
        "cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(\"COCO-Detection/faster_rcnn_X_101_32x8d_FPN_3x.yaml\")  # Let training initialize from model zoo\n",
        "cfg.SOLVER.IMS_PER_BATCH = 2\n",
        "cfg.SOLVER.BASE_LR = 0.0009  # pick a good LR\n",
        "cfg.SOLVER.MAX_ITER = 4000    \n",
        "cfg.SOLVER.STEPS = []        # do not decay learning rate\n",
        "cfg.MODEL.ROI_HEADS.BATCH_SIZE_PER_IMAGE = 512\n",
        "cfg.MODEL.ROI_HEADS.NUM_CLASSES = 1 \n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "P4rql8pNokE4"
      },
      "source": [
        "### Training"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "7d3KxiHO_0gb"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Create a DefaultTrainer using the above config and train the model\n",
        "# TODO: approx 5 lines\n",
        "'''\n",
        "os.makedirs(cfg.OUTPUT_DIR, exist_ok=True)\n",
        "trainer = DefaultTrainer(cfg) \n",
        "trainer.resume_or_load(resume=False)\n",
        "trainer.train()\n",
        "\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "fRVEiICco3SV"
      },
      "source": [
        "### Evaluation and Visualization"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "VYCIXdMZvDYL"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# After training the model, you need to update cfg.MODEL.WEIGHTS\n",
        "# Define a DefaultPredictor\n",
        "'''\n",
        "cfg.MODEL.WEIGHTS = os.path.join(cfg.OUTPUT_DIR, \"model_final.pth\")  # path to the model we just trained\n",
        "cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.6   # set a custom testing threshold\n",
        "predictor = DefaultPredictor(cfg)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "_hRCf86KGi5v",
        "collapsed": true
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Visualize the output for 3 random test samples\n",
        "# TODO: approx 10 lines\n",
        "'''\n",
        "from detectron2.utils.visualizer import ColorMode\n",
        "for i in range(3):\n",
        "    d = data_detection_test[i]    \n",
        "    im = cv2.imread(d[\"file_name\"])\n",
        "    outputs = predictor(im)  # format is documented at https://detectron2.readthedocs.io/tutorials/models.html#model-output-format\n",
        "    v = Visualizer(im[:, :, ::-1],\n",
        "                   metadata=metadata_detection_test, \n",
        "                   scale=0.5, \n",
        "                   instance_mode=ColorMode.IMAGE_BW   # remove the colors of unsegmented pixels. This option is only available for segmentation models\n",
        "    )\n",
        "    out = v.draw_instance_predictions(outputs[\"instances\"].to(\"cpu\"))\n",
        "    cv2_imshow(out.get_image()[:, :, ::-1])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "D0wRdlcKo6BD"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Use COCOEvaluator and build_detection_train_loader\n",
        "# You can save the output predictions using inference_on_dataset\n",
        "# TODO: approx 5 lines\n",
        "'''\n",
        "\n",
        "from detectron2.evaluation import COCOEvaluator, inference_on_dataset\n",
        "from detectron2.data import build_detection_test_loader\n",
        "evaluator = COCOEvaluator(\"data_detection_val\", output_dir=\"./output\")\n",
        "val_loader = build_detection_test_loader(cfg, \"data_detection_val\")\n",
        "print(inference_on_dataset(predictor.model, val_loader, evaluator))\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "njh2YIkQ5pPK"
      },
      "outputs": [],
      "source": [
        "from matplotlib import pyplot as plt\n",
        "training = os.path.join(cfg.OUTPUT_DIR,'metrics.json')\n",
        "\n",
        "with open(training, 'r') as handle:\n",
        "    processed_data = [json.loads(line) for line in handle]\n",
        "\n",
        "train_data = np.zeros((len(processed_data),3))\n",
        "\n",
        "for index_iter in range(len(processed_data)):\n",
        "  item_iter = processed_data[index_iter]\n",
        "  train_data[index_iter,0] = int(item_iter[\"iteration\"])\n",
        "  train_data[index_iter,1] = float(item_iter[\"total_loss\"])\n",
        "  train_data[index_iter,2] = float(item_iter[\"fast_rcnn/cls_accuracy\"])\n",
        "\n",
        "plt.figure()\n",
        "plt.plot(train_data[:,0], train_data[:,1], 'r-')\n",
        "plt.ylabel('total loss')\n",
        "plt.xlabel('iteration')\n",
        "plt.show()\n",
        "\n",
        "plt.figure()\n",
        "plt.plot(train_data[:,0], train_data[:,2], 'r-')\n",
        "plt.ylabel('class accuracy')\n",
        "plt.xlabel('iteration')\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "3trI2kvthNLD"
      },
      "outputs": [],
      "source": [
        "train_data[:,0]"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "EwYvbwcjpKBk"
      },
      "source": [
        "### Improvements\n",
        "\n",
        "For this part, you can bring any improvement which you have by adding new input parameters to the previous functions or defining new functions and variables."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "98_M4TooqSs2"
      },
      "source": [
        "## Part 2: Semantic Segmentation"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "ByAEsMtIPLrO"
      },
      "source": [
        "### Data Loader"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "peQ95zLuIpkk"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Write a function that returns the cropped image and corresponding mask regarding the target bounding box\n",
        "# idx is the index of the target bbox in the data\n",
        "# high-resolution image could be passed or could be load from data['file_name']\n",
        "# You can use the mask attribute of detectron2.utils.visualizer.GenericMask \n",
        "#     to convert the segmentation annotations to binary masks\n",
        "# TODO: approx 10 lines\n",
        "'''\n",
        "\n",
        "def get_instance_sample(data, idx, img=None):\n",
        "  image = cv2.imread(data['file_name'])\n",
        "  instance = data['annotations'][idx]\n",
        "  box_coord = instance['bbox'] # Box coordinates\n",
        "  obj_img = image[int(box_coord[1]):int(box_coord[1]+box_coord[3]),int(box_coord[0]):int(box_coord[0]+box_coord[2]),:]\n",
        "  \n",
        "  masked_image = detectron2.utils.visualizer.GenericMask(instance['segmentation'], height = image.shape[0], width = image.shape[1])\n",
        "  obj_mask = masked_image.mask[int(box_coord[1]):int(box_coord[1]+box_coord[3]),int(box_coord[0]):int(box_coord[0]+box_coord[2])]\n",
        "  return obj_img, obj_mask"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "sxrc9X_pjzj-"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# We have provided a template data loader for your segmentation training\n",
        "# You need to complete the __getitem__() function before running the code\n",
        "# You may also need to add data augmentation or normalization in here\n",
        "'''\n",
        "\n",
        "class PlaneDataset(Dataset):\n",
        "  def __init__(self, set_name, data_list):\n",
        "      self.transforms = transforms.Compose([\n",
        "          transforms.ToTensor(), # Converting the image to tensor and change the image format (Channels-Last => Channels-First)\n",
        "      ])\n",
        "      self.set_name = set_name\n",
        "      self.data = data_list\n",
        "      self.instance_map = []\n",
        "      for i, d in enumerate(self.data):\n",
        "        for j in range(len(d['annotations'])):\n",
        "          self.instance_map.append([i,j])\n",
        "\n",
        "  '''\n",
        "  # you can change the value of length to a small number like 10 for debugging of your training procedure and overfeating\n",
        "  # make sure to use the correct length for the final training\n",
        "  '''\n",
        "  def __len__(self):\n",
        "      return len(self.instance_map)\n",
        "\n",
        "  def numpy_to_tensor(self, img, mask):\n",
        "    if self.transforms is not None:\n",
        "        img = self.transforms(img)\n",
        "    img = torch.tensor(img, dtype=torch.float)\n",
        "    mask = torch.tensor(mask, dtype=torch.float)\n",
        "    return img, mask\n",
        "\n",
        "  '''\n",
        "  # Complete this part by using get_instance_sample function\n",
        "  # make sure to resize the img and mask to a fixed size (for example 128*128)\n",
        "  # you can use \"interpolate\" function of pytorch or \"numpy.resize\"\n",
        "  # TODO: 5 lines\n",
        "  '''\n",
        "  def __getitem__(self, idx):\n",
        "    if torch.is_tensor(idx):\n",
        "        idx = idx.tolist()\n",
        "    idx = self.instance_map[idx]\n",
        "    data = self.data[idx[0]]\n",
        "    obj_img, obj_mask = get_instance_sample(data, idx[1], img=None)\n",
        "    \n",
        "    resize_img = cv2.resize(obj_img, (128, 128), interpolation= cv2.INTER_NEAREST)\n",
        "    resize_mask = cv2.resize(obj_mask, (128, 128), interpolation= cv2.INTER_NEAREST)\n",
        "    \n",
        "    img, mask = self.numpy_to_tensor(resize_img, resize_mask)\n",
        "\n",
        "\n",
        "    return img, mask\n",
        "\n",
        "def get_plane_dataset(set_name='train', batch_size=2, data_list=[]):\n",
        "    #my_data_list = DatasetCatalog.get(\"data_detection_{}\".format(set_name))\n",
        "    dataset = PlaneDataset(set_name, data_list)\n",
        "    loader = DataLoader(dataset, batch_size=batch_size, num_workers=4,\n",
        "                                              pin_memory=True, shuffle=True)\n",
        "    return loader, dataset"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "m6eH3NKaQQfc"
      },
      "source": [
        "### Network"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "'''\n",
        "# convolution module as a template layer consists of conv2d layer, batch normalization, and relu activation\n",
        "'''\n",
        "class conv(nn.Module):\n",
        "    def __init__(self, in_ch, out_ch, activation=True):\n",
        "        super(conv, self).__init__()\n",
        "        if(activation):\n",
        "          self.layer = nn.Sequential(\n",
        "             nn.Conv2d(in_ch, out_ch, 3, padding=1),\n",
        "             nn.BatchNorm2d(out_ch),\n",
        "             nn.ReLU(inplace=True)\n",
        "          )\n",
        "        else:\n",
        "          self.layer = nn.Sequential(\n",
        "             nn.Conv2d(in_ch, out_ch, 3, padding=1)  \n",
        "             )\n",
        "\n",
        "    def forward(self, x):\n",
        "        x = self.layer(x)\n",
        "        return x\n",
        "\n",
        "'''\n",
        "# downsampling module equal to a conv module followed by a max-pool layer\n",
        "'''\n",
        "class down(nn.Module):\n",
        "    def __init__(self, in_ch, out_ch):\n",
        "        super(down, self).__init__()\n",
        "        self.layer = nn.Sequential(\n",
        "            conv(in_ch, out_ch),\n",
        "            nn.MaxPool2d(2)\n",
        "            )\n",
        "\n",
        "    def forward(self, x):\n",
        "        x = self.layer(x)\n",
        "        return x\n",
        "\n",
        "'''\n",
        "# upsampling module equal to a upsample function followed by a conv module\n",
        "'''\n",
        "class up(nn.Module):\n",
        "    def __init__(self, in_ch, out_ch, bilinear=False):\n",
        "        super(up, self).__init__()\n",
        "        if bilinear:\n",
        "            self.up = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)\n",
        "        else:\n",
        "            self.up = nn.ConvTranspose2d(in_ch, in_ch, 2, stride=2)\n",
        "\n",
        "        self.conv = conv(in_ch, out_ch)\n",
        "\n",
        "    def forward(self, x):\n",
        "        y = self.up(x)\n",
        "        y = self.conv(y)\n",
        "        return y\n",
        "\n",
        "'''\n",
        "# the main model which you need to complete by using above modules.\n",
        "# you can also modify the above modules in order to improve your results.\n",
        "'''\n",
        "class MyModel(nn.Module):\n",
        "    def __init__(self):\n",
        "        super(MyModel, self).__init__()\n",
        "        \n",
        "        # Encoder\n",
        "        \n",
        "        self.input_conv = conv(3, 4)\n",
        "        self.down = down(4, 8)\n",
        "        \n",
        "        # Decoder\n",
        "        \n",
        "        self.up = up(8, 4)\n",
        "        self.output_conv = conv(4, 1, False) # ReLu activation is removed to keep the logits for the loss function\n",
        "        \n",
        "\n",
        "    def forward(self, input):\n",
        "      y = self.input_conv(input)\n",
        "      y = self.down(y)\n",
        "      y = self.up(y)\n",
        "      output = self.output_conv(y)\n",
        "      return output\n",
        "\n",
        "class MyModel(nn.Module):\n",
        "    def __init__(self):\n",
        "        super(MyModel, self).__init__()\n",
        "        \n",
        "        # Encoder\n",
        "        \n",
        "        self.conv1 = conv(3, 64)       \n",
        "        self.down1 = down(64, 64)       \n",
        "        self.conv2 = conv(64, 128)     \n",
        "        self.down2 = down(128, 128)      \n",
        "        self.conv3 = conv(128, 256)      \n",
        "        self.down3 = down(256, 256)      \n",
        "        self.conv4 = conv(256, 512)     \n",
        "        self.down4 = down(512, 512)      \n",
        "        self.conv5 = conv(512, 1024)       \n",
        "        self.down5 = down(1024, 1024)      \n",
        "        self.conv6 = conv(1024, 2048)     \n",
        "        \n",
        "        \n",
        "        # Decoder\n",
        "        \n",
        "        self.conv7 = conv(2048, 1024)    \n",
        "        self.up7 = up(1024, 1024)         \n",
        "        self.conv8 = conv(1024, 512)     \n",
        "        self.conv9 = conv(512, 512)    \n",
        "        self.up2 = up(512, 512)          \n",
        "        self.conv10 = conv(512, 512) \n",
        "        self.conv11 = conv(512, 256)     \n",
        "        self.up3 = up(256, 256)         \n",
        "        self.conv12 = conv(256, 256) \n",
        "        self.conv13 = conv(256, 128)     \n",
        "        self.up4 = up(128+128, 128)        \n",
        "        self.conv14 = conv(128, 128)  \n",
        "        self.conv15 = conv(128, 64)      \n",
        "        self.up5 = up(64+64, 64)            \n",
        "        self.conv16 = conv(64, 64)    \n",
        "        self.conv17 = conv(64, 32)       \n",
        "        self.conv18 = conv(32, 1, False) \n",
        "        \n",
        "\n",
        "    def forward(self, input):\n",
        "      y_cat_1 = self.conv2(self.down1(conv1(input)))\n",
        "      y_cat_2 = self.conv3(self.down2(y_cat_1))\n",
        "      y_cat_3 = self.conv4(self.down3(y_cat_2))\n",
        "      y_cat_4 = self.conv5(self.down4(y_cat_3))\n",
        "      y_cat_5 = self.conv6(self.down5(y_cat_4))\n",
        "            \n",
        "      y_out_1 = self.up1(self.conv7(y_cat_5))\n",
        "      y_out_2 = torch.cat([y_cat_5, y_out_1], dim = 1)\n",
        "      \n",
        "      y_out_3 = self.up2(self.conv9(self.conv8(y_out_2)))\n",
        "      y_out_4 = torch.cat([y_cat_4, y_out_3], dim = 1)\n",
        "\n",
        "      y_out_5 = self.up3(self.conv11(self.conv10(y_out_4)))\n",
        "      y_out_6 = torch.cat([y_cat_3, y_out_5], dim = 1)\n",
        "\n",
        "      y_out_7 = self.up4(self.conv13(self.conv12(y_out_6)))\n",
        "      y_out_8 = torch.cat([y_cat_2, y_out_7], dim = 1)\n",
        "\n",
        "      y_out_9 = self.up5(self.conv15(self.conv14(y_out_8)))\n",
        "      y_out_10 = torch.cat([y_cat_1, y_out_9], dim = 1)\n",
        "\n",
        "      output = self.conv19(self.conv17(self.conv16(y_out_10)))\n",
        "\n",
        "      return output"
      ],
      "metadata": {
        "id": "FiJeFpuYUBmO"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "rQj86vD9QT_Z"
      },
      "source": [
        "### Training\n",
        "\n",
        "Run the following if you want to change Loss function."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "\n",
        "\"\"\"\n",
        "get_tp_fp_fn, SoftDiceLoss, and DC_and_CE/TopK_loss are from https://github.com/MIC-DKFZ/nnUNet/blob/master/nnunet/training/loss_functions\n",
        "\"\"\"\n",
        "\n",
        "import torch\n",
        "from ND_Crossentropy import CrossentropyND, TopKLoss, WeightedCrossEntropyLoss\n",
        "from torch import nn\n",
        "from torch.autograd import Variable\n",
        "from torch import einsum\n",
        "import numpy as np\n",
        "\n",
        "def softmax_helper(x):\n",
        "    # copy from: https://github.com/MIC-DKFZ/nnUNet/blob/master/nnunet/utilities/nd_softmax.py\n",
        "    rpt = [1 for _ in range(len(x.size()))]\n",
        "    rpt[1] = x.size(1)\n",
        "    x_max = x.max(1, keepdim=True)[0].repeat(*rpt)\n",
        "    e_x = torch.exp(x - x_max)\n",
        "    return e_x / e_x.sum(1, keepdim=True).repeat(*rpt)\n",
        "\n",
        "def sum_tensor(inp, axes, keepdim=False):\n",
        "    # copy from: https://github.com/MIC-DKFZ/nnUNet/blob/master/nnunet/utilities/tensor_utilities.py\n",
        "    axes = np.unique(axes).astype(int)\n",
        "    if keepdim:\n",
        "        for ax in axes:\n",
        "            inp = inp.sum(int(ax), keepdim=True)\n",
        "    else:\n",
        "        for ax in sorted(axes, reverse=True):\n",
        "            inp = inp.sum(int(ax))\n",
        "    return inp\n",
        "\n",
        "def get_tp_fp_fn(net_output, gt, axes=None, mask=None, square=False):\n",
        "    \"\"\"\n",
        "    net_output must be (b, c, x, y(, z)))\n",
        "    gt must be a label map (shape (b, 1, x, y(, z)) OR shape (b, x, y(, z))) or one hot encoding (b, c, x, y(, z))\n",
        "    if mask is provided it must have shape (b, 1, x, y(, z)))\n",
        "    :param net_output:\n",
        "    :param gt:\n",
        "    :param axes:\n",
        "    :param mask: mask must be 1 for valid pixels and 0 for invalid pixels\n",
        "    :param square: if True then fp, tp and fn will be squared before summation\n",
        "    :return:\n",
        "    \"\"\"\n",
        "    if axes is None:\n",
        "        axes = tuple(range(2, len(net_output.size())))\n",
        "\n",
        "    shp_x = net_output.shape\n",
        "    shp_y = gt.shape\n",
        "\n",
        "    with torch.no_grad():\n",
        "        if len(shp_x) != len(shp_y):\n",
        "            gt = gt.view((shp_y[0], 1, *shp_y[1:]))\n",
        "\n",
        "        if all([i == j for i, j in zip(net_output.shape, gt.shape)]):\n",
        "            # if this is the case then gt is probably already a one hot encoding\n",
        "            y_onehot = gt\n",
        "        else:\n",
        "            gt = gt.long()\n",
        "            y_onehot = torch.zeros(shp_x)\n",
        "            if net_output.device.type == \"cuda\":\n",
        "                y_onehot = y_onehot.cuda(net_output.device.index)\n",
        "            y_onehot.scatter_(1, gt, 1)\n",
        "\n",
        "    tp = net_output * y_onehot\n",
        "    fp = net_output * (1 - y_onehot)\n",
        "    fn = (1 - net_output) * y_onehot\n",
        "\n",
        "    if mask is not None:\n",
        "        tp = torch.stack(tuple(x_i * mask[:, 0] for x_i in torch.unbind(tp, dim=1)), dim=1)\n",
        "        fp = torch.stack(tuple(x_i * mask[:, 0] for x_i in torch.unbind(fp, dim=1)), dim=1)\n",
        "        fn = torch.stack(tuple(x_i * mask[:, 0] for x_i in torch.unbind(fn, dim=1)), dim=1)\n",
        "\n",
        "    if square:\n",
        "        tp = tp ** 2\n",
        "        fp = fp ** 2\n",
        "        fn = fn ** 2\n",
        "\n",
        "    tp = sum_tensor(tp, axes, keepdim=False)\n",
        "    fp = sum_tensor(fp, axes, keepdim=False)\n",
        "    fn = sum_tensor(fn, axes, keepdim=False)\n",
        "\n",
        "    return tp, fp, fn\n",
        "\n",
        "\n",
        "class GDiceLoss(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, smooth=1e-5):\n",
        "        \"\"\"\n",
        "        Generalized Dice;\n",
        "        Copy from: https://github.com/LIVIAETS/surface-loss/blob/108bd9892adca476e6cdf424124bc6268707498e/losses.py#L29\n",
        "        paper: https://arxiv.org/pdf/1707.03237.pdf\n",
        "        tf code: https://github.com/NifTK/NiftyNet/blob/dev/niftynet/layer/loss_segmentation.py#L279\n",
        "        \"\"\"\n",
        "        super(GDiceLoss, self).__init__()\n",
        "\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "\n",
        "    def forward(self, net_output, gt):\n",
        "        shp_x = net_output.shape # (batch size,class_num,x,y,z)\n",
        "        shp_y = gt.shape # (batch size,1,x,y,z)\n",
        "        # one hot code for gt\n",
        "        with torch.no_grad():\n",
        "            if len(shp_x) != len(shp_y):\n",
        "                gt = gt.view((shp_y[0], 1, *shp_y[1:]))\n",
        "\n",
        "            if all([i == j for i, j in zip(net_output.shape, gt.shape)]):\n",
        "                # if this is the case then gt is probably already a one hot encoding\n",
        "                y_onehot = gt\n",
        "            else:\n",
        "                gt = gt.long()\n",
        "                y_onehot = torch.zeros(shp_x)\n",
        "                if net_output.device.type == \"cuda\":\n",
        "                    y_onehot = y_onehot.cuda(net_output.device.index)\n",
        "                y_onehot.scatter_(1, gt, 1)\n",
        "\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            net_output = self.apply_nonlin(net_output)\n",
        "    \n",
        "        # copy from https://github.com/LIVIAETS/surface-loss/blob/108bd9892adca476e6cdf424124bc6268707498e/losses.py#L29\n",
        "        w: torch.Tensor = 1 / (einsum(\"bcxyz->bc\", y_onehot).type(torch.float32) + 1e-10)**2\n",
        "        intersection: torch.Tensor = w * einsum(\"bcxyz, bcxyz->bc\", net_output, y_onehot)\n",
        "        union: torch.Tensor = w * (einsum(\"bcxyz->bc\", net_output) + einsum(\"bcxyz->bc\", y_onehot))\n",
        "        divided: torch.Tensor =  - 2 * (einsum(\"bc->b\", intersection) + self.smooth) / (einsum(\"bc->b\", union) + self.smooth)\n",
        "        gdc = divided.mean()\n",
        "\n",
        "        return gdc\n",
        "\n",
        "\n",
        "\n",
        "def flatten(tensor):\n",
        "    \"\"\"Flattens a given tensor such that the channel axis is first.\n",
        "    The shapes are transformed as follows:\n",
        "       (N, C, D, H, W) -> (C, N * D * H * W)\n",
        "    \"\"\"\n",
        "    C = tensor.size(1)\n",
        "    # new axis order\n",
        "    axis_order = (1, 0) + tuple(range(2, tensor.dim()))\n",
        "    # Transpose: (N, C, D, H, W) -> (C, N, D, H, W)\n",
        "    transposed = tensor.permute(axis_order).contiguous()\n",
        "    # Flatten: (C, N, D, H, W) -> (C, N * D * H * W)\n",
        "    return transposed.view(C, -1)\n",
        "\n",
        "class GDiceLossV2(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, smooth=1e-5):\n",
        "        \"\"\"\n",
        "        Generalized Dice;\n",
        "        Copy from: https://github.com/wolny/pytorch-3dunet/blob/6e5a24b6438f8c631289c10638a17dea14d42051/unet3d/losses.py#L75\n",
        "        paper: https://arxiv.org/pdf/1707.03237.pdf\n",
        "        tf code: https://github.com/NifTK/NiftyNet/blob/dev/niftynet/layer/loss_segmentation.py#L279\n",
        "        \"\"\"\n",
        "        super(GDiceLossV2, self).__init__()\n",
        "\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "\n",
        "    def forward(self, net_output, gt):\n",
        "        shp_x = net_output.shape # (batch size,class_num,x,y,z)\n",
        "        shp_y = gt.shape # (batch size,1,x,y,z)\n",
        "        # one hot code for gt\n",
        "        with torch.no_grad():\n",
        "            if len(shp_x) != len(shp_y):\n",
        "                gt = gt.view((shp_y[0], 1, *shp_y[1:]))\n",
        "\n",
        "            if all([i == j for i, j in zip(net_output.shape, gt.shape)]):\n",
        "                # if this is the case then gt is probably already a one hot encoding\n",
        "                y_onehot = gt\n",
        "            else:\n",
        "                gt = gt.long()\n",
        "                y_onehot = torch.zeros(shp_x)\n",
        "                if net_output.device.type == \"cuda\":\n",
        "                    y_onehot = y_onehot.cuda(net_output.device.index)\n",
        "                y_onehot.scatter_(1, gt, 1)\n",
        "\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            net_output = self.apply_nonlin(net_output)\n",
        "\n",
        "        input = flatten(net_output)\n",
        "        target = flatten(y_onehot)\n",
        "        target = target.float()\n",
        "        target_sum = target.sum(-1)\n",
        "        class_weights = Variable(1. / (target_sum * target_sum).clamp(min=self.smooth), requires_grad=False)\n",
        "\n",
        "        intersect = (input * target).sum(-1) * class_weights\n",
        "        intersect = intersect.sum()\n",
        "\n",
        "        denominator = ((input + target).sum(-1) * class_weights).sum()\n",
        "\n",
        "        return  - 2. * intersect / denominator.clamp(min=self.smooth)\n",
        "\n",
        "\n",
        "class SSLoss(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, batch_dice=False, do_bg=True, smooth=1.,\n",
        "                 square=False):\n",
        "        \"\"\"\n",
        "        Sensitivity-Specifity loss\n",
        "        paper: http://www.rogertam.ca/Brosch_MICCAI_2015.pdf\n",
        "        tf code: https://github.com/NifTK/NiftyNet/blob/df0f86733357fdc92bbc191c8fec0dcf49aa5499/niftynet/layer/loss_segmentation.py#L392\n",
        "        \"\"\"\n",
        "        super(SSLoss, self).__init__()\n",
        "\n",
        "        self.square = square\n",
        "        self.do_bg = do_bg\n",
        "        self.batch_dice = batch_dice\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "        self.r = 0.1 # weight parameter in SS paper\n",
        "\n",
        "    def forward(self, net_output, gt, loss_mask=None):\n",
        "        shp_x = net_output.shape\n",
        "        shp_y = gt.shape\n",
        "        # class_num = shp_x[1]\n",
        "        \n",
        "        with torch.no_grad():\n",
        "            if len(shp_x) != len(shp_y):\n",
        "                gt = gt.view((shp_y[0], 1, *shp_y[1:]))\n",
        "\n",
        "            if all([i == j for i, j in zip(net_output.shape, gt.shape)]):\n",
        "                # if this is the case then gt is probably already a one hot encoding\n",
        "                y_onehot = gt\n",
        "            else:\n",
        "                gt = gt.long()\n",
        "                y_onehot = torch.zeros(shp_x)\n",
        "                if net_output.device.type == \"cuda\":\n",
        "                    y_onehot = y_onehot.cuda(net_output.device.index)\n",
        "                y_onehot.scatter_(1, gt, 1)\n",
        "\n",
        "        if self.batch_dice:\n",
        "            axes = [0] + list(range(2, len(shp_x)))\n",
        "        else:\n",
        "            axes = list(range(2, len(shp_x)))\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            net_output = self.apply_nonlin(net_output)\n",
        "        \n",
        "        # no object value\n",
        "        bg_onehot = 1 - y_onehot\n",
        "        squared_error = (y_onehot - net_output)**2\n",
        "        specificity_part = sum_tensor(squared_error*y_onehot, axes)/(sum_tensor(y_onehot, axes)+self.smooth)\n",
        "        sensitivity_part = sum_tensor(squared_error*bg_onehot, axes)/(sum_tensor(bg_onehot, axes)+self.smooth)\n",
        "\n",
        "        ss = self.r * specificity_part + (1-self.r) * sensitivity_part\n",
        "\n",
        "        if not self.do_bg:\n",
        "            if self.batch_dice:\n",
        "                ss = ss[1:]\n",
        "            else:\n",
        "                ss = ss[:, 1:]\n",
        "        ss = ss.mean()\n",
        "\n",
        "        return ss\n",
        "\n",
        "\n",
        "\n",
        "class SoftDiceLoss(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, batch_dice=False, do_bg=True, smooth=1.,\n",
        "                 square=False):\n",
        "        \"\"\"\n",
        "        paper: https://arxiv.org/pdf/1606.04797.pdf\n",
        "        \"\"\"\n",
        "        super(SoftDiceLoss, self).__init__()\n",
        "\n",
        "        self.square = square\n",
        "        self.do_bg = do_bg\n",
        "        self.batch_dice = batch_dice\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "\n",
        "    def forward(self, x, y, loss_mask=None):\n",
        "        shp_x = x.shape\n",
        "\n",
        "        if self.batch_dice:\n",
        "            axes = [0] + list(range(2, len(shp_x)))\n",
        "        else:\n",
        "            axes = list(range(2, len(shp_x)))\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            x = self.apply_nonlin(x)\n",
        "\n",
        "        tp, fp, fn = get_tp_fp_fn(x, y, axes, loss_mask, self.square)\n",
        "\n",
        "        dc = (2 * tp + self.smooth) / (2 * tp + fp + fn + self.smooth)\n",
        "\n",
        "        if not self.do_bg:\n",
        "            if self.batch_dice:\n",
        "                dc = dc[1:]\n",
        "            else:\n",
        "                dc = dc[:, 1:]\n",
        "        dc = dc.mean()\n",
        "\n",
        "        return -dc\n",
        "\n",
        "class IoULoss(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, batch_dice=False, do_bg=True, smooth=1.,\n",
        "                 square=False):\n",
        "        \"\"\"\n",
        "        paper: https://link.springer.com/chapter/10.1007/978-3-319-50835-1_22\n",
        "        \n",
        "        \"\"\"\n",
        "        super(IoULoss, self).__init__()\n",
        "\n",
        "        self.square = square\n",
        "        self.do_bg = do_bg\n",
        "        self.batch_dice = batch_dice\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "\n",
        "    def forward(self, x, y, loss_mask=None):\n",
        "        shp_x = x.shape\n",
        "\n",
        "        if self.batch_dice:\n",
        "            axes = [0] + list(range(2, len(shp_x)))\n",
        "        else:\n",
        "            axes = list(range(2, len(shp_x)))\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            x = self.apply_nonlin(x)\n",
        "\n",
        "        tp, fp, fn = get_tp_fp_fn(x, y, axes, loss_mask, self.square)\n",
        "\n",
        "\n",
        "        iou = (tp + self.smooth) / (tp + fp + fn + self.smooth)\n",
        "\n",
        "        if not self.do_bg:\n",
        "            if self.batch_dice:\n",
        "                iou = iou[1:]\n",
        "            else:\n",
        "                iou = iou[:, 1:]\n",
        "        iou = iou.mean()\n",
        "\n",
        "        return -iou\n",
        "\n",
        "class TverskyLoss(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, batch_dice=False, do_bg=True, smooth=1.,\n",
        "                 square=False):\n",
        "        \"\"\"\n",
        "        paper: https://arxiv.org/pdf/1706.05721.pdf\n",
        "        \"\"\"\n",
        "        super(TverskyLoss, self).__init__()\n",
        "\n",
        "        self.square = square\n",
        "        self.do_bg = do_bg\n",
        "        self.batch_dice = batch_dice\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "        self.alpha = 0.3\n",
        "        self.beta = 0.7\n",
        "\n",
        "    def forward(self, x, y, loss_mask=None):\n",
        "        shp_x = x.shape\n",
        "\n",
        "        if self.batch_dice:\n",
        "            axes = [0] + list(range(2, len(shp_x)))\n",
        "        else:\n",
        "            axes = list(range(2, len(shp_x)))\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            x = self.apply_nonlin(x)\n",
        "\n",
        "        tp, fp, fn = get_tp_fp_fn(x, y, axes, loss_mask, self.square)\n",
        "\n",
        "\n",
        "        tversky = (tp + self.smooth) / (tp + self.alpha*fp + self.beta*fn + self.smooth)\n",
        "\n",
        "        if not self.do_bg:\n",
        "            if self.batch_dice:\n",
        "                tversky = tversky[1:]\n",
        "            else:\n",
        "                tversky = tversky[:, 1:]\n",
        "        tversky = tversky.mean()\n",
        "\n",
        "        return -tversky\n",
        "\n",
        "class FocalTversky_loss(nn.Module):\n",
        "    \"\"\"\n",
        "    paper: https://arxiv.org/pdf/1810.07842.pdf\n",
        "    author code: https://github.com/nabsabraham/focal-tversky-unet/blob/347d39117c24540400dfe80d106d2fb06d2b99e1/losses.py#L65\n",
        "    \"\"\"\n",
        "    def __init__(self, tversky_kwargs, gamma=0.75):\n",
        "        super(FocalTversky_loss, self).__init__()\n",
        "        self.gamma = gamma\n",
        "        self.tversky = TverskyLoss(**tversky_kwargs)\n",
        "\n",
        "    def forward(self, net_output, target):\n",
        "        tversky_loss = 1 + self.tversky(net_output, target) # = 1-tversky(net_output, target)\n",
        "        focal_tversky = torch.pow(tversky_loss, self.gamma)\n",
        "        return focal_tversky\n",
        "\n",
        "\n",
        "class AsymLoss(nn.Module):\n",
        "    def __init__(self, apply_nonlin=None, batch_dice=False, do_bg=True, smooth=1.,\n",
        "                 square=False):\n",
        "        \"\"\"\n",
        "        paper: https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8573779\n",
        "        \"\"\"\n",
        "        super(AsymLoss, self).__init__()\n",
        "\n",
        "        self.square = square\n",
        "        self.do_bg = do_bg\n",
        "        self.batch_dice = batch_dice\n",
        "        self.apply_nonlin = apply_nonlin\n",
        "        self.smooth = smooth\n",
        "        self.beta = 1.5\n",
        "\n",
        "    def forward(self, x, y, loss_mask=None):\n",
        "        shp_x = x.shape\n",
        "\n",
        "        if self.batch_dice:\n",
        "            axes = [0] + list(range(2, len(shp_x)))\n",
        "        else:\n",
        "            axes = list(range(2, len(shp_x)))\n",
        "\n",
        "        if self.apply_nonlin is not None:\n",
        "            x = self.apply_nonlin(x)\n",
        "\n",
        "        tp, fp, fn = get_tp_fp_fn(x, y, axes, loss_mask, self.square)# shape: (batch size, class num)\n",
        "        weight = (self.beta**2)/(1+self.beta**2)\n",
        "        asym = (tp + self.smooth) / (tp + weight*fn + (1-weight)*fp + self.smooth)\n",
        "\n",
        "        if not self.do_bg:\n",
        "            if self.batch_dice:\n",
        "                asym = asym[1:]\n",
        "            else:\n",
        "                asym = asym[:, 1:]\n",
        "        asym = asym.mean()\n",
        "\n",
        "        return -asym\n",
        "\n",
        "class DC_and_CE_loss(nn.Module):\n",
        "    def __init__(self, soft_dice_kwargs, ce_kwargs, aggregate=\"sum\"):\n",
        "        super(DC_and_CE_loss, self).__init__()\n",
        "        self.aggregate = aggregate\n",
        "        self.ce = CrossentropyND(**ce_kwargs)\n",
        "        self.dc = SoftDiceLoss(apply_nonlin=softmax_helper, **soft_dice_kwargs)\n",
        "\n",
        "    def forward(self, net_output, target):\n",
        "        dc_loss = self.dc(net_output, target)\n",
        "        ce_loss = self.ce(net_output, target)\n",
        "        if self.aggregate == \"sum\":\n",
        "            result = ce_loss + dc_loss\n",
        "        else:\n",
        "            raise NotImplementedError(\"nah son\") # reserved for other stuff (later)\n",
        "        return result\n",
        "\n",
        "class PenaltyGDiceLoss(nn.Module):\n",
        "    \"\"\"\n",
        "    paper: https://openreview.net/forum?id=H1lTh8unKN\n",
        "    \"\"\"\n",
        "    def __init__(self, gdice_kwargs):\n",
        "        super(PenaltyGDiceLoss, self).__init__()\n",
        "        self.k = 2.5\n",
        "        self.gdc = GDiceLoss(apply_nonlin=softmax_helper, **gdice_kwargs)\n",
        "\n",
        "    def forward(self, net_output, target):\n",
        "        gdc_loss = self.gdc(net_output, target)\n",
        "        penalty_gdc = gdc_loss / (1 + self.k * (1 - gdc_loss))\n",
        "\n",
        "        return penalty_gdc\n",
        "\n",
        "        \n",
        "\n",
        "class DC_and_topk_loss(nn.Module):\n",
        "    def __init__(self, soft_dice_kwargs, ce_kwargs, aggregate=\"sum\"):\n",
        "        super(DC_and_topk_loss, self).__init__()\n",
        "        self.aggregate = aggregate\n",
        "        self.ce = TopKLoss(**ce_kwargs)\n",
        "        self.dc = SoftDiceLoss(apply_nonlin=softmax_helper, **soft_dice_kwargs)\n",
        "\n",
        "    def forward(self, net_output, target):\n",
        "        dc_loss = self.dc(net_output, target)\n",
        "        ce_loss = self.ce(net_output, target)\n",
        "        if self.aggregate == \"sum\":\n",
        "            result = ce_loss + dc_loss\n",
        "        else:\n",
        "            raise NotImplementedError(\"nah son\") # reserved for other stuff (later?)\n",
        "        return result\n",
        "\n",
        "\n",
        "\n",
        "class ExpLog_loss(nn.Module):\n",
        "    \"\"\"\n",
        "    paper: 3D Segmentation with Exponential Logarithmic Loss for Highly Unbalanced Object Sizes\n",
        "    https://arxiv.org/pdf/1809.00076.pdf\n",
        "    \"\"\"\n",
        "    def __init__(self, soft_dice_kwargs, wce_kwargs, gamma=0.3):\n",
        "        super(ExpLog_loss, self).__init__()\n",
        "        self.wce = WeightedCrossEntropyLoss(**wce_kwargs)\n",
        "        self.dc = SoftDiceLoss(apply_nonlin=softmax_helper, **soft_dice_kwargs)\n",
        "        self.gamma = gamma\n",
        "\n",
        "    def forward(self, net_output, target):\n",
        "        dc_loss = -self.dc(net_output, target) # weight=0.8\n",
        "        wce_loss = self.wce(net_output, target) # weight=0.2\n",
        "        # with torch.no_grad():\n",
        "        #     print('dc loss:', dc_loss.cpu().numpy(), 'ce loss:', ce_loss.cpu().numpy())\n",
        "        #     a = torch.pow(-torch.log(torch.clamp(dc_loss, 1e-6)), self.gamma)\n",
        "        #     b = torch.pow(-torch.log(torch.clamp(ce_loss, 1e-6)), self.gamma)\n",
        "        #     print('ExpLog dc loss:', a.cpu().numpy(), 'ExpLogce loss:', b.cpu().numpy())\n",
        "        #     print('*'*20)\n",
        "        explog_loss = 0.8*torch.pow(-torch.log(torch.clamp(dc_loss, 1e-6)), self.gamma) + \\\n",
        "            0.2*wce_loss\n",
        "\n",
        "        return explog_loss\n",
        "\n"
      ],
      "metadata": {
        "id": "Y3vqnJKLeeJy"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "MaZuO4SKSBuF"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# The following is a basic training procedure to train the network\n",
        "# You need to update the code to get the best performance\n",
        "# TODO: approx ? lines\n",
        "'''\n",
        "\n",
        "# Set the hyperparameters\n",
        "num_epochs = 10\n",
        "batch_size = 4\n",
        "learning_rate = 0.005\n",
        "weight_decay = 1e-5\n",
        "\n",
        "model = MyModel() # initialize the model\n",
        "model = model.cuda() # move the model to GPU\n",
        "loader, _ = get_plane_dataset('train', batch_size, data_detection_train) # initialize data_loader\n",
        "crit = nn.BCEWithLogitsLoss() # Define the loss function\n",
        "optim = torch.optim.SGD(model.parameters(), lr=learning_rate, weight_decay=weight_decay) # Initialize the optimizer as SGD\n",
        "\n",
        "# start the training procedure\n",
        "for epoch in range(num_epochs):\n",
        "  total_loss = 0\n",
        "  for (img, mask) in tqdm(loader):\n",
        "    img = torch.tensor(img, device=torch.device('cuda'), requires_grad = True)\n",
        "    mask = torch.tensor(mask, device=torch.device('cuda'), requires_grad = True)\n",
        "    pred = model(img)\n",
        "\n",
        "#    loss = softDiceLoss(torch.reshape(pred,(torch.Tensor.size(mask))), mask)\n",
        "#    loss = PenaltyGDiceLoss(torch.reshape(pred,(torch.Tensor.size(mask))), mask)\n",
        "    loss = crit(torch.reshape(pred,(torch.Tensor.size(mask))), mask)\n",
        "    optim.zero_grad()\n",
        "    loss.backward()\n",
        "    optim.step()\n",
        "    total_loss += loss.cpu().data\n",
        "  print(\"Epoch: {}, Loss: {}\".format(epoch, total_loss/len(loader)))\n",
        "  torch.save(model.state_dict(), '{}/output/{}_segmentation_model.pth'.format(BASE_DIR, epoch))\n",
        "\n",
        "'''\n",
        "# Saving the final model\n",
        "'''\n",
        "torch.save(model.state_dict(), '{}/output/final_segmentation_model.pth'.format(BASE_DIR))\n"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "torch.Tensor.size(mask)"
      ],
      "metadata": {
        "id": "tFszM9rea4Ub",
        "outputId": "11aef3cd-1761-4e68-ad88-0c3c8d4e6df5",
        "colab": {
          "base_uri": "https://localhost:8080/"
        }
      },
      "execution_count": null,
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "torch.Size([3, 128, 128])"
            ]
          },
          "metadata": {},
          "execution_count": 15
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "0dyez1fyQYw7"
      },
      "source": [
        "### Evaluation and Visualization"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "batch_size = 8\n",
        "#filename = 'finalized_model.sav'\n",
        "#joblib.dump(model, filename)\n",
        "\n",
        "model = MyModel().cuda()\n",
        "model.load_state_dict(torch.load('{}/output/final_segmentation_model.pth'.format(BASE_DIR)))\n",
        "model = model.eval() # chaning the model to evaluation mode will fix the bachnorm layers\n",
        "loader, dataset = get_plane_dataset('val', batch_size, data_detection_val)\n",
        "\n",
        "total_iou = 0\n",
        "i = 0 # shows the number of instances (images)\n",
        "for (img, mask) in tqdm(loader):\n",
        "  with torch.no_grad():\n",
        "    img = img.cuda() \n",
        "    mask = mask.cuda() \n",
        "    pred = model(img)  \n",
        "  '''\n",
        "  ## Complete the code by obtaining the IoU for each img and print the final Mean IoU\n",
        "  '''\n",
        "  mask_prediction = F.sigmoid(pred) # Set the value to be between zero and one.\n",
        "  mask_prediction[mask_prediction > 0.5] = 1\n",
        "  mask_prediction[mask_prediction <= 0.5] = 0\n",
        "  \n",
        "  for instance_no in range(img.shape[0]): # Getting each image (instance) from the batch\n",
        "    \n",
        "    real_instance_mask = mask[instance_no] \n",
        "    instance_mask_prediction = mask_prediction[instance_no] \n",
        "    \n",
        "    # using AND and OR to find union and intersec\n",
        "    intersection = torch.logical_and(real_instance_mask, instance_mask_prediction)\n",
        "    union = torch.logical_or(real_instance_mask, instance_mask_prediction)\n",
        "    \n",
        "    total_iou += (torch.sum(intersection) / torch.sum(union)).item()\n",
        "    i += 1\n",
        "mean_iou = total_iou/i\n",
        "\n",
        "\n",
        "print(\"Mean IoU of all validation set: {}\".format(mean_iou))"
      ],
      "metadata": {
        "id": "ImWKLXBE-UZq"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "trans = transforms.Compose([\n",
        "          transforms.ToTensor(), # Converting the image to tensor and change the image format (Channels-Last => Channels-First) [0,255] --> [0,1]\n",
        "      ])\n",
        "imgs_dir = BASE_DIR # I have manually cropped three images from one of the images and uploaded them to the directore of the assignment in my google drive with names: P1088_1, P1088_2, P1088_3\n"
      ],
      "metadata": {
        "id": "mBAMEVXxBqse"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "from matplotlib import pyplot as plt\n",
        "plt.figure()\n",
        "# I have to copy the losses here as the runtime ended :(\n",
        "loss_for_plot = [0.23167967796325684, 0.18061771988868713,0.1651030033826828,0.15397490561008453,0.1451379805803299,0.13646839559078217]\n",
        "plt.title('Training loss over number of epochs')\n",
        "plt.plot(loss_for_plot)\n",
        "plt.ylabel('Training loss')\n",
        "plt.xlabel('# of epochs-1')"
      ],
      "metadata": {
        "id": "Mnu6-l8obV4F"
      },
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "jbmTj9JICiKz"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Visualize 3 sample outputs\n",
        "# TODO: approx 5 lines\n",
        "'''\n",
        "\n",
        "for i in range(4):\n",
        "  img = cv2.imread('{}/P{}.png'.format(BASE_DIR,i+1))\n",
        "  img = cv2.resize(img, (128,128), interpolation= cv2.INTER_NEAREST)\n",
        "  cv2_imshow(img)  \n",
        "  img = trans(img) # 3 * 128 * 128\n",
        "  img = torch.tensor(img, dtype=torch.float).unsqueeze(0) \n",
        "  with torch.no_grad():\n",
        "    img = img.cuda() \n",
        "    pred = model(img)          \n",
        "  sigmoid_pred = torch.sigmoid(pred) \n",
        "  sigmoid_pred[sigmoid_pred >= 0.5] = 1\n",
        "  sigmoid_pred[sigmoid_pred < 0.5] = 0\n",
        "  pred_mask = sigmoid_pred[0][0].cpu().numpy()\n",
        "  cv2_imshow(pred_mask * 255) "
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "navoiGdrqaZT"
      },
      "source": [
        "## Part 3: Instance Segmentation\n",
        "\n",
        "In this part, you need to obtain the instance segmentation results for the test data by using the trained segmentation model in the previous part and the detection model in Part 1."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "vBwk33DGBowP"
      },
      "source": [
        "### Get Prediction"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "crrZ8TG-Ot2J"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Define a new function to obtain the prediction mask by passing a sample data\n",
        "# For this part, you need to use all the previous parts (predictor, get_instance_sample, data preprocessings, etc)\n",
        "# It is better to keep everything (as well as the output of this funcion) on gpu as tensors to speed up the operations.\n",
        "# pred_mask is the instance segmentation result and should have different values for different planes.\n",
        "# TODO: approx 35 lines\n",
        "'''\n",
        "import copy\n",
        "def get_prediction_mask(data):\n",
        "  img = cv2.imread(data['file_name'])\n",
        "  gt_mask = np.zeros((img.shape[0], img.shape[1]))\n",
        "  pred_mask = np.zeros((img.shape[0], img.shape[1]))\n",
        "  gt_mask = np.zeros((img.shape[0], img.shape[1])) # H*W\n",
        "\n",
        "  # taking the gt_mask from the data\n",
        "  if len(data[\"annotations\"]) > 0: # check if it is training and validation data\n",
        "    \n",
        "    for plane_no in range(len(data[\"annotations\"])):\n",
        "      \n",
        "      gt_bbox = data[\"annotations\"][plane_no][\"bbox\"] # coordinate box of the instance \n",
        "      _, obj_mask = get_instance_sample(data, plane_no, None) \n",
        "      \n",
        "      gt_mask[int(gt_bbox[1]):int(gt_bbox[1]+gt_bbox[3]), \n",
        "              int(gt_bbox[0]):int(gt_bbox[0]+gt_bbox[2])] = copy.deepcopy(obj_mask) * 0.5 * (1 + plane_no/len(data[\"annotations\"]))\n",
        "\n",
        "  \n",
        "  # pred_mask:\n",
        "  trans = transforms.Compose([\n",
        "          transforms.ToTensor(), # Converting the image to tensor and change the image format (Channels-Last => Channels-First)\n",
        "      ])\n",
        "  \n",
        "  outputs = predictor(img)\n",
        "  pred_coord_box = outputs[\"instances\"].pred_boxes.tensor.cpu() \n",
        "  for plane_no in range(pred_coord_box.shape[0]):\n",
        "    coordin = np.round(pred_coord_box[plane_no,:])\n",
        "    img_cropped = img[int(coordin[1]):int(coordin[3]),\n",
        "                    int(coordin[0]):int(coordin[2]),\n",
        "                    :]\n",
        "    img_resized = cv2.resize(img_cropped, (128, 128), interpolation= cv2.INTER_NEAREST)                        \n",
        "    img_input_0 = trans(img_resized) # tensor 3 * 128 * 128\n",
        "    img_input = torch.tensor(img_input_0, dtype=torch.float).unsqueeze(0)\n",
        "    with torch.no_grad():\n",
        "      img_input = img_input.cuda()      # 1 * 3 * 128 * 128\n",
        "      pred = model(img_input)           # 1 * 1 * 128 * 128\n",
        "    obj_mask_pred = torch.sigmoid(pred)[0][0].cpu().numpy() # [0,1] 128 * 128  \n",
        "    obj_mask_pred = cv2.resize(obj_mask_pred, \n",
        "                                (img_cropped.shape[1], img_cropped.shape[0]), \n",
        "                                interpolation= cv2.INTER_NEAREST) # convert to the intial size\n",
        "    obj_mask_pred[obj_mask_pred <= 0.5] = 0\n",
        "    obj_mask_pred[obj_mask_pred > 0.5] = 0.5 + 0.5 * (plane_no + 1) / pred_coord_box.shape[0]\n",
        "    pred_mask[int(coordin[1]):int(coordin[3]),\n",
        "              int(coordin[0]):int(coordin[2])] = copy.deepcopy(obj_mask_pred) \n",
        "\n",
        "  img = torch.tensor(img, dtype=torch.float).cuda()\n",
        "  gt_mask = torch.tensor(gt_mask, dtype=torch.float).cuda()\n",
        "  pred_mask = torch.tensor(pred_mask, dtype=torch.float).cuda()\n",
        "\n",
        "  return img, gt_mask, pred_mask # gt_mask could be all zero when the ground truth is not given.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "fc7TSK6EBi9u"
      },
      "source": [
        "### Visualization and Submission"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "H7T2YX8MBiGO"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# Visualise the output prediction as well as the GT Mask and Input image for a sample input\n",
        "# TODO: approx 10 lines\n",
        "'''\n",
        "for i in range(3):\n",
        "  data = data_detection_test[i]\n",
        "  img, gt_mask, pred_mask = get_prediction_mask(data)\n",
        "  img = cv2.resize(img.cpu().numpy(), (128,128), interpolation= cv2.INTER_NEAREST)\n",
        "  cv2_imshow(img)\n",
        "  #gt_mask = cv2.resize(gt_mask.cpu().numpy(), (128,128), interpolation= cv2.INTER_NEAREST)\n",
        "  cv2_imshow(gt_mask.cpu().numpy()*255)\n",
        "  #pred_mask = cv2.resize(pred_mask.cpu().numpy(), (128,128), interpolation= cv2.INTER_NEAREST)\n",
        "  cv2_imshow(pred_mask.cpu().numpy()*255)\n",
        "  "
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "uPo_03up-g_f"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# ref: https://www.kaggle.com/rakhlin/fast-run-length-encoding-python\n",
        "# https://www.kaggle.com/c/airbus-ship-detection/overview/evaluation\n",
        "'''\n",
        "def rle_encoding(x):\n",
        "    '''\n",
        "    x: pytorch tensor on gpu, 1 - mask, 0 - background\n",
        "    Returns run length as list\n",
        "    '''\n",
        "    dots = torch.where(torch.flatten(x.long())==1)[0]\n",
        "    if(len(dots)==0):\n",
        "      return []\n",
        "    inds = torch.where(dots[1:]!=dots[:-1]+1)[0]+1\n",
        "    inds = torch.cat((torch.tensor([0], device=torch.device('cuda'), dtype=torch.long), inds))\n",
        "    tmpdots = dots[inds]\n",
        "    inds = torch.cat((inds, torch.tensor([len(dots)], device=torch.device('cuda'))))\n",
        "    inds = inds[1:] - inds[:-1]\n",
        "    runs = torch.cat((tmpdots, inds)).reshape((2,-1))\n",
        "    runs = torch.flatten(torch.transpose(runs, 0, 1)).cpu().data.numpy()\n",
        "    return ' '.join([str(i) for i in runs])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "zv0rab2LJev-"
      },
      "outputs": [],
      "source": [
        "'''\n",
        "# You need to upload the csv file on kaggle\n",
        "# The speed of your code in the previous parts highly affects the running time of this part\n",
        "'''\n",
        "\n",
        "preddic = {\"ImageId\": [], \"EncodedPixels\": []}\n",
        "\n",
        "'''\n",
        "# Writing the predictions of the training set\n",
        "'''\n",
        "for my_data_list in [data_detection_train, data_detection_val]:\n",
        "  for i in tqdm(range(len(my_data_list)), position=0, leave=True):\n",
        "    sample = my_data_list[i]\n",
        "    sample['image_id'] = sample['file_name'].split(\"/\")[-1][:-4]\n",
        "    img, true_mask, pred_mask = get_prediction_mask(sample)\n",
        "    inds = torch.unique(pred_mask)\n",
        "    if(len(inds)==1):\n",
        "      preddic['ImageId'].append(sample['image_id'])\n",
        "      preddic['EncodedPixels'].append([])\n",
        "    else:\n",
        "      for index in inds:\n",
        "        if(index == 0):\n",
        "          continue\n",
        "        tmp_mask = (pred_mask==index)\n",
        "        encPix = rle_encoding(tmp_mask)\n",
        "        preddic['ImageId'].append(sample['image_id'])\n",
        "        preddic['EncodedPixels'].append(encPix)\n",
        "\n",
        "'''\n",
        "# Writing the predictions of the test set\n",
        "'''\n",
        "\n",
        "my_data_list = data_detection_test\n",
        "for i in tqdm(range(len(my_data_list)), position=0, leave=True):\n",
        "  sample = my_data_list[i]\n",
        "  sample['image_id'] = sample['file_name'].split(\"/\")[-1][:-4]\n",
        "  img, true_mask, pred_mask = get_prediction_mask(sample)\n",
        "  inds = torch.unique(pred_mask)\n",
        "  if(len(inds)==1):\n",
        "    preddic['ImageId'].append(sample['image_id'])\n",
        "    preddic['EncodedPixels'].append([])\n",
        "  else:\n",
        "    for j, index in enumerate(inds):\n",
        "      if(index == 0):\n",
        "        continue\n",
        "      tmp_mask = (pred_mask==index).double()\n",
        "      encPix = rle_encoding(tmp_mask)\n",
        "      preddic['ImageId'].append(sample['image_id'])\n",
        "      preddic['EncodedPixels'].append(encPix)\n",
        "\n",
        "pred_file = open(\"{}/pred.csv\".format(BASE_DIR), 'w')\n",
        "pd.DataFrame(preddic).to_csv(pred_file, index=False)\n",
        "pred_file.close()\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "p7nN4SduqrpI"
      },
      "source": [
        "## Part 4: Mask R-CNN\n",
        "\n",
        "For this part you need to follow a same procedure to part 2 with the configs of Mask R-CNN, other parts are generally the same as part 2."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "axWf7drKNXYd"
      },
      "source": [
        "### Data Loader"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "lG5slAhQNjE7"
      },
      "source": [
        "### Network"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KG1pnKLMOcjS"
      },
      "outputs": [],
      "source": [
        "os.makedirs(os.path.join(BASE_DIR,'output/p4/'), exist_ok=True)\n",
        "cfg2 = get_cfg()\n",
        "cfg2.OUTPUT_DIR = \"{}/output/p4\".format(BASE_DIR)\n",
        "cfg2.merge_from_file(model_zoo.get_config_file(\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml\"))\n",
        "cfg2.DATASETS.TRAIN = (\"data_detection_train\",)\n",
        "cfg2.DATASETS.TEST = ()\n",
        "cfg2.DATALOADER.NUM_WORKERS = 8\n",
        "cfg2.MODEL.WEIGHTS = model_zoo.get_checkpoint_url(\"COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml\")  # Let training initialize from model zoo\n",
        "cfg2.SOLVER.IMS_PER_BATCH = 2\n",
        "cfg2.SOLVER.BASE_LR = 0.0008  # pick a good LR\n",
        "cfg2.SOLVER.MAX_ITER = 500    \n",
        "cfg2.SOLVER.STEPS = []        # do not decay learning rate\n",
        "cfg2.MODEL.ROI_HEADS.BATCH_SIZE_PER_IMAGE = 512\n",
        "cfg2.MODEL.ROI_HEADS.NUM_CLASSES = 1 "
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "t7ifeV1sNvtt"
      },
      "source": [
        "### Training"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "tc4K0Nz5OeKk"
      },
      "outputs": [],
      "source": [
        "os.makedirs(cfg2.OUTPUT_DIR, exist_ok=True)\n",
        "trainer = DefaultTrainer(cfg2) \n",
        "trainer.resume_or_load(resume=False)\n",
        "trainer.train()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "298QruFnNxyn"
      },
      "source": [
        "### Evaluation and Visualization"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "KcGwV5-9Oetp"
      },
      "outputs": [],
      "source": [
        "from matplotlib import pyplot as plt\n",
        "training_file = os.path.join(cfg2.OUTPUT_DIR,'metrics.json')\n",
        "with open(training_file, 'r') as handle:\n",
        "    processed_data = [json.loads(line) for line in handle]\n",
        "\n",
        "train_data = np.zeros((len(processed_data),3))\n",
        "for index_iter in range(len(processed_data)):\n",
        "  item_iter = processed_data[index_iter]\n",
        "  train_data[index_iter,0] = int(item_iter[\"iteration\"])\n",
        "  train_data[index_iter,1] = float(item_iter[\"total_loss\"])\n",
        "  train_data[index_iter,2] = float(item_iter[\"fast_rcnn/cls_accuracy\"])\n",
        "\n",
        "plt.figure()\n",
        "plt.plot(train_data[:,0], train_data[:,1], 'r-')\n",
        "plt.ylabel('total loss')\n",
        "plt.xlabel('iteration')\n",
        "\n",
        "plt.figure()\n",
        "plt.plot(train_data[:,0], train_data[:,2], 'b-')\n",
        "plt.ylabel('total loss')\n",
        "plt.xlabel('iteration')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "l_3wS2BFLLGp"
      },
      "outputs": [],
      "source": [
        "cfg2.MODEL.WEIGHTS = os.path.join(cfg2.OUTPUT_DIR, \"model_final.pth\")  # path to the model we just trained\n",
        "cfg2.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.6   # set a custom testing threshold\n",
        "maskrcn_predictor = DefaultPredictor(cfg2)\n",
        "\n",
        "from detectron2.utils.visualizer import ColorMode\n",
        "for i in range(3):\n",
        "    d = data_detection_test[i]    \n",
        "    im = cv2.imread(d[\"file_name\"])\n",
        "    outputs = maskrcn_predictor(im)  # format is documented at https://detectron2.readthedocs.io/tutorials/models.html#model-output-format\n",
        "    v = Visualizer(im[:, :, ::-1],\n",
        "                   metadata=metadata_detection_test, \n",
        "                   scale=0.5, \n",
        "                   instance_mode=ColorMode.IMAGE_BW   # remove the colors of unsegmented pixels. This option is only available for segmentation models\n",
        "    )\n",
        "    out = v.draw_instance_predictions(outputs[\"instances\"].to(\"cpu\"))\n",
        "    cv2_imshow(out.get_image()[:, :, ::-1])\n",
        "\n",
        "\n"
      ]
    }
  ],
  "metadata": {
    "colab": {
      "collapsed_sections": [],
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "gpuClass": "standard",
    "accelerator": "GPU"
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
